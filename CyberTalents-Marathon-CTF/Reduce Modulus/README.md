
# Challenge Name: Reduce Modulus


![date](https://img.shields.io/badge/date-08.03.2021-brightgreen.svg)  
![solved in time of CTF](https://img.shields.io/badge/solved-in%20time%20of%20CTF-brightgreen.svg)   
![crypto category](https://img.shields.io/badge/category-Cryptography-blueviolet.svg)   
![level](https://img.shields.io/badge/level-Medium-blue.svg)
![score](https://img.shields.io/badge/score-100-blue.svg)


## Attached files

- [reduce-modulus.py](reduce-modulus.py)

## Detailed solution

As the challenge not acessible right now i didn't remeber the full description (to update) 

We can see in the encryption script that we have a RSA encryption. We have the cipherctext c, the modulus N (n1*n2) and the exponent e 

The modulus used for encryption is N = modulus[0] * modulus[1] and it's a combinaison of some primes  

```
modulus = (Primes[0] * Primes[1] * Primes[2] * Primes[3], Primes[0] * Primes[1]) 
``` 

We have the two parts : 
- n1 = Primes[0] * Primes[1] * Primes[2] * Primes[3]
- n2 = Primes[0] * Primes[1]

```
n1 = 58899560795422629508383709585815596674993413635981165980320127271644038316448725758306722451998784991954419091526089159750869500335163383766827243981828688851948124591111627934859094536105678156714083380927689539385480719433890644570016706624506640312364077682372260047937960244512523766943378334280751887151
n2 = 10035997187541816220681016469393172095726015614633459513695480820099536637633364416223346540578858375371324216891862234038678667156169323844411428795236483
```
To be able to descrypt the RSA ciphertext we need to factorise the modulus and the used primes. I'll use [factoredb](http://factordb.com/)   
```
n1 = q1 * p1 * r1 

q1 = 97376413457495379727538733988115472170316568275353708109214217512313027597677
p1 = 103063943630687425230399745410466615279125356292442540958979279268474247260079
r1 = 5868829942333741533880409398990244343870920499661847816940231710761952732286819725819022038868194875443763043775871130747678069401049126641963650974100197
``` 

```
n2 = q2 * p2
q2 = 97376413457495379727538733988115472170316568275353708109214217512313027597677
p2 = 103063943630687425230399745410466615279125356292442540958979279268474247260079
```  
We already know that the first par and seconf part of the modulus share same primes Primes[0] and Primes[1], and the first part containes 4 primes but we only find 2 and r1 = Primes[2] * Primes[3] 

I was not able de factorise r1 so i started searching for other RSA attacks. In our case we have a multi prime RSA, i found that we can use the n2 if it's larger than the message. 

So to reduced the modulus we need to use the second component of the public key which is a prime factor N(n2) = Primes[0] * Primes[1] = p1 * q1 = p2 * q2 

Now we need to use second part of public key to calclul phi and decrypt ciphertext with it 

```phi(N) = ( q — 1 ) * ( p — 1 )```  Euler’s Totient for the number N.  
```d = inverse( e, phi )``` the private key with the MODULAR INVERSE of e and phi. ```e = 65537```  

To decrypt the message :

```m ≡ c^d (mod n)```

I'm gonna use the python library Pycryptodome

```python
from Crypto.Util.number import *

c = 493411990714034701192036868925033382533813449023272468886834417275865894890277610897602010608126211732489729110637453412478527735277532858305194132432995412335314758844973458067236971260497417393244304994147175160121126866274637094642084286422204250530071767179407437175780827344723433812174890560874797281085881372866235919836442489439131953350250339903321616150128653702980111364606793773693115742802148096105255600570826866081538329662788508308910574300106675
n1 = 58899560795422629508383709585815596674993413635981165980320127271644038316448725758306722451998784991954419091526089159750869500335163383766827243981828688851948124591111627934859094536105678156714083380927689539385480719433890644570016706624506640312364077682372260047937960244512523766943378334280751887151
n2 = 10035997187541816220681016469393172095726015614633459513695480820099536637633364416223346540578858375371324216891862234038678667156169323844411428795236483
q1 = 97376413457495379727538733988115472170316568275353708109214217512313027597677
p1 = 103063943630687425230399745410466615279125356292442540958979279268474247260079
r1 = 5868829942333741533880409398990244343870920499661847816940231710761952732286819725819022038868194875443763043775871130747678069401049126641963650974100197

q2 = 97376413457495379727538733988115472170316568275353708109214217512313027597677
p2 = 103063943630687425230399745410466615279125356292442540958979279268474247260079

e = 65537

#n = n1*n2

phi = (p2 - 1) * (q2 - 1) 
#phi = (p1 - 1) * (q1 - 1) * (r1 - 1) * (p2 - 1) * (q2 - 1) also worked

d = inverse(e, phi)

flag = pow(c,d,n2)
print(long_to_bytes(flag).decode())
```  







## Flag

```
flag{R3duc3_M0dul3s}
```
